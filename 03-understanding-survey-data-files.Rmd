# Understanding survey data files {#c03}

```{r}
#| include = FALSE
knitr::opts_chunk$set(eval = TRUE)
```

* [Reading survey documentation](#reading-survey-documentation)
* [Best practices for loading data into R](#best-practices-for-loading-data-into-r)
* [Loading survey files into R](#loading-survey-files-into-r)
* [Missing data]
* [Accounting for skip patterns]

## Reading survey documentation

The first step in survey analysis is reading the documentation. Survey documentation can vary in its organization, thoroughness, and ease of use. We recommend focusing on key sections when beginning an analysis.

* **Introduction:** The introduction orients us to the survey. Generally, this section provides the background of the project, purpose of the study, and main research questions.
* **Study design:** The study design section describes how the survey was prepared and administered.
* **Sample:** The sample section describes the sampling of the survey: how cases were selected, any sampling error that occurred, and limitations of the sample. This section can contain recommendations on how to use sampling weights. This documentation is critical in successfully running our analysis. We go into more detail in [Chapter 05:Specifying sample designs in srvyr](#c05).

### Searching for public-use data



## Best practices for loading data into R

We recommend a project-based workflow for analysis projects as described in Hadley Wickham and Garrett Grolemund's book, R for Data Science. [define project-based workflow here] Projects help us practice file system discipline, since we put all the files related to a single project in a designated folder. Since all associated files are in a single location, they are easy to find and organize.

The RStudio IDE supports project-based workflows. When we create a project in RStudio, it creates a `.Rproj` file that store settings specific to that project.

The {here} package enables easy file referencing. In a project-based workflow, all paths are relative and, by default, relative to the project’s folder. Use the `here()` function from the here package to build the path when you load or save data.

## Loading survey files into R

Survey files come in different file types depending on the program used to output them. R gives us the flexibility to load datasets regardless of their file extension. Here are examples of common public-use survey file formats:

* Delimiter-separated text files
* Excel files
* `.rda` files
* `.dta` files from Stata
* `.sas` files from SAS
* `.sav` files from SPSS

For uncommon file formats, we recommend searching StackOverflow or similar community sites to learn how to load them into R.

### Loading delimiter-separated files into R

Delimiter-separated files use specific characters to separate values. For example, CSV files are separated by commas. These file types are widely used and we can use many applications to read and write them.

We can read delimiter-separated files using the tidyverse package {readr}. The {readr} package supports the following files with these `readr::read_*()` functions:

* `read_csv()`: Comma-separated values (CSV) files
* `read_tsv()`: Tab-separated values (TSV) files
* `read_delim()`: Delimiter-separated files (CSV and TSV are important special cases)
* `read_fwf()`: Fixed-width files
* `read_table()`: Whitespace-separated files
* `read_log()`: Web log files

```{r}
library(readr)
read_csv("anes_timeseries_2020_csv_20220210.csv")
```

### Loading Excel files into R

Excel, the spreadsheet software program from Microsoft, is a common file format. We can load Excel spreadsheets into R using the {readxl} package. The {readxl} package supports both the legacy `.xls` format and the modern `.xlsx` format. 

Let's review the options by running `??readxl::read_excel`:

```
read_excel(
  path,
  sheet = NULL,
  range = NULL,
  col_names = TRUE,
  col_types = NULL,
  na = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  guess_max = min(1000, n_max),
  progress = readxl_progress(),
  .name_repair = "unique"
)
```

We load our file into R by running `read_excel()` and specifying the arguments as necessary:

```{r}
library(readxl)
read_excel(path = "anes_timeseries_2020_csv_20220210.xlsx")
```

### Loading Stata, SAS, and SPSS files into R

The {haven} package from the tidyverse imports a variety of proprietary data formats: Stata `.dta` files, SAS `.sas7bdat` and `.sas7bcat` files, and SPSS `.sav` files. These file types can contain labels for variables and values. Using {haven} allows us to retain important information when analyzing tibbles in R.

Let's look at Stata first. We can import `.dat` file formats using `haven::read_dat()`. Explore the `haven::read_dat()` options by searching for the help page, `??haven::read_dta`.

```r
read_dta(
  file,
  encoding = NULL,
  col_select = NULL,
  skip = 0,
  n_max = Inf,
  .name_repair = "unique"
)
```

We load our file into R by running `read_dat()` and specifying the arguments as necessary:

```{r}
library(haven)

(anes_dta <-
  read_dta(file = "anes_timeseries_2020_stata_20220210.dta"))
```
The {haven} package has equivalent functions for SAS and SPSS: `read_sas()` and `read_sav()` respectively. Let's load the ANES 2020 SPSS file:

```{r}
#| eval = TRUE
library(haven)

(anes_sav <-
  read_sav(file = "anes_timeseries_2020_spss_20220210.sav"))
```

#### Output objects

The output objects are tibbles, a specific type of data frames that make it easier to work in the tidyverse. More information can be found in the [Tibbles chapter of R for Data Science](https://r4ds.had.co.nz/tibbles.html).

#### Importing labeled data

Stata, SPSS, and SAS files often contain labeled variables and values. Labels provide descriptive information about categorical data. With the {haven} package, we can import labels from Stata, SPSS, and SAS into R without loss of fidelity using a special class of data called `haven_labelled`.

Taking a look at the ANES SPSS file:

```{r, R.options=list(max.print = 6)}
#| message = FALSE,
#| eval = TRUE
library(dplyr)

anes_sav %>% 
  select(1:6) %>% 
  glimpse()
```

Note that the categorical variables have a type of `<dbl+lbl>`, meaning that they are labeled. We can confirm with `is.labelled()`:

```{r}
haven::is.labelled(anes_sav$V200002)
```

To see everything that a column contains, we can use `attributes()`. 
Note that the variable labels are stored in `$label` while the value labels are stored in `$labels`.

```{r}
attributes(anes_sav$V200002) 
```

#### Working with labeled data in R

Once we import labeled numeric or character vectors into R, we want to create an *intermediate* object that we convert into a regular R data frame. That is, we should not intend to keep the labeled vectors indefinitely.

There are two ways of creating this intermediate object:

1. Convert the vector into a factor 

Factors in R are vectors of integer values that display corresponding character values. The possible character values are called levels, which are sorted in alphabetical order by default. Factors are often used for categorical data, where there is a finite number of distinct values.

Here is a dummy example of factors:

```{r}
response <- c("strongly agree", "agree", "agree", "disagree")
response_levels <- c("strongly agree", "agree", "disagree", "strongly disagree")
factors <- factor(response, levels = response_levels)
factors
```

Recall that factors are integer vectors, though they may look like character strings. We can confirm by looking at the vector's structure:

```{r}
#| eval = TRUE
glimpse(factors)
```

R's factors differ from Stata, SPSS, or SAS' labeled vectors. However, we can leverage them to assign a dataset's value labels with `as_factor()`.

```{r}
anes_sav %>% 
  transmute(V200002 = as_factor(V200002))
```

Using the {purrr} package, we can apply `as_factor()` to all to the columns of the dataset.

```{r}
anes_sav_factor <- anes_sav %>% 
  mutate(across(where(is.labelled),
                as_factor))

anes_sav_factor %>% 
  select(1:6) %>% 
  glimpse()
```

2. Stripping the labels

The second option is to 'zap', or strip, the labels from the dataset.

We can remove the variable label using `zap_label()`:

```{r}
zap_label(anes_sav) %>% 
  select(1:6) %>% 
  glimpse()
```

To remove the value labels, we can use `zap_labels()`:

```{r}
#| eval = FALSE
zap_labels(anes_sav) %>% 
  select(1:6) %>% 
  glimpse()
```

## Missing data

Stata, SPSS, and SAS files each handle missing values in different ways. For SAS and Stata, {haven} provides `tagged` missing values which extend R's regular `NA` by adding a single character label. A `tagged` missing value adds a single character label to R's regular `NA`. These values behave identical to `NA` in regular R operations while preserving the value of the tag.

SPSS’s user-defined values work differently to SAS and Stata. Each column can have either up to three distinct values that are considered as missing, or a range. Haven provides `labeled_spss()` as a subclass of `labeled()` to model additional user-defined missing values.

## Working with missing data
