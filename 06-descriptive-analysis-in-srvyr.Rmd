# Descriptive analyses in srvyr {#c06}

## Introduction
<!-- Definition of descriptive analytics in the context of complex survey analysis -->
Descriptive analysis describes and summarizes the basic quantitative information of survey data. Common descriptive analyses include the frequency of observations, distributions of responses, or the mean of a numeric variable. In addition to getting a sense of what our data includes, descriptive analysis helps us identify potential errors and assess outliers. Running descriptive analysis allows us to investigate our data and gain insight into the information it contains, and it is crucial for conducting further survey analysis.
<!-- Importance of considering the design and sampling of the survey when analyzing data-->

For complex survey analysis, we must consider the available design and sampling elements when conducting descriptive analysis. This requires reading the survey documentation (as described in [Chapter 03](#c03)) to apply the appropriate sampling weights, PSUs, strata, and replicate weights. Neglecting to incorporate these elements can lead to inaccurate descriptive analyses.

The functions in the {srvyr} package allow us to run descriptive analyses while applying design and sampling elements. We can run multiple calculations in the same command thanks to the 'pipe-able' functions. The package also provides consistent return types so we can use outputs with other packages like {ggplot2}.
<!-- Overview of the topics covered in the chapter -->
This chapter describes the types of descriptive analytics and the steps involved in running descriptive analysis with {srvyr}.
<!-- ## Techniques for descriptive analyses -->

```{r}
#| include: false
library(srvyr)
library(survey)
data(api)

dstrata <- apistrat %>%
  as_survey_design(strata = stype, weights = pw)
```

## Types of descriptive analyses

Descriptive analysis can be categorized into univariate and multivariate analysis, depending on the number of variables we describe. Below, we describe the descriptive analysis for single or multiple variables and a minimal example of the {srvyr} functions associated with the measures. In the next section, we will explain each of the functions in-depth.

#### A brief refresher on the `dplyr::summarize()` function
<!-- TODO: Put this in a callout box -->
Several functions in {srvyr} must be called within the `dplyr::summarize()` function. Recall that `summarize()` collapses many values down to a single summary:

```{r}
mtcars %>% 
  summarize(mean_hp = mean(hp))
```

These verbs can be used in conjunction with `group_by()`, applying the functions on a group-by-group basis to create grouped summaries.

```{r}
mtcars %>% 
  group_by(cyl) %>% 
  summarize(mean_hp = mean(hp))
```
<!--TODO: end callout note-->

### Univariate analysis

Univariate analysis examines a single variable at a time. A single variable has three categories of characteristics: distribution, central tendency, and dispersion. Each characteristic simplifies our dataset. Therefore, it is important to look at multiple characteristics rather than rely on a single one to describe the data.

#### Measures of distribution

Measures of distribution describe how often an event or response occurs. These measures include proportions and quantiles.

* Examples: the proportion of students in California who did or did not receive an award based on their Academic Performance score; the proportion of U.S. citizens who voted in the last election; the distribution of household income in India divided into quantiles

The {srvyr} package includes several functions for determining measures of distribution. 

* The `survey_total()` function calculates totals
* The `survey_count()` and `survey_tally()` functions calculate weighted observations by group
* The `survey_prop()` function calculates proportions
* The `survey_quantile()` function calculates quantiles
* The `survey_ratio()` function calculates ratios

```{r}
# Calculate the survey proportion of awards

dstrata %>%
  group_by(awards) %>%
  summarise(pct = survey_prop())
```
Running the above, we see the weighted percentage of students who received awards is 63.9%.

#### Measures of central tendency

Measures of central tendency find the central (or average) responses. These include the mean, median, and mode.

* Examples: Average 2000 Academic Performance Index in California, the median house price in Canada

The `survey_mean()` and `survey_median()` functions from {srvyr} calculate mean and median using survey data, respectively. These functions must be called from within `summarize()`.

```{r}
# Calculate survey mean of variable api00

dstrata %>%
  summarise(api00_mean = survey_mean(api00),
            api00_median = survey_median(api00))
```

The weighted average score in 2000 was 662.3, and the median score was 668.

#### Measures of dispersion

Measures of dispersion describe how data spreads around the central tendency. These measures include the range and standard deviation.

* Examples: The standard deviation of the 2000 Academic Performance Index in California, the range between the minimum and maximum electricity expenditure in Ohio

The `survey_var()` and `survey_sd()` functions from the {srvyr} package calculate population variance and standard deviation using survey methods, respectively.

```{r}
# Calculate the variance and standard deviation 
dstrata %>%
  summarise(api99_var = survey_var(api00),
            api99_sd = survey_sd(api00))
```

In this case, the variance for the 1999 scores was 15190.59	with a standard error of 1273.3 and a standard deviation was 123.3.

### Bivariate/multivariate analysis

Bivariate analysis concerns the relationship between two variables. Multivariate analysis studies the relationship between multiple variables. A common analysis includes correlation, which is a number between -1 and +1 that denotes the strength of the linear relationship between two variables.

* Examples: Relationship between academic performance scores in 1999 and 2000; relationship between age and income

<!--- TODO: check if this is still true in December 2023 --->
The {srvyr} package does not include a function for calculating correlations for survey variables. We can use the {survey} package's `svyvar()` to estimate the variance between the variables and then run `cov2cor()` to get the correlation.

```{r}
var <- survey::svyvar(~api00 + api99, design = dstrata)
vmat <- as.matrix(var)
attr(vmat, "var") <- NULL # Remove extra info
attr(vmat, "statistic") <- NULL # Remove extra info
stats::cov2cor(vmat)

# Another option, using the native R pipe and labelled::remove_attributes()

dstrata |>
 survey::svyvar(~api00 + api99, design = _) |>
 as.matrix(x = _) |>
 labelled::remove_attributes(x = _, "var") |>
 labelled::remove_attributes(x = _, "statistic") |>
 stats::cov2cor(V = _)
```

These is a strong correlation (0.97) between a district's score in 1999 and 2000.

## Deciding on descriptive analyses
<!-- TODO: simplify this sentence -->
We choose which measures to look at depending on which are appropriate for the type of variable we are examining. Variables are classified as categorical/nominal, ordinal, and interval/ratio.

* Categorical/nominal data: variables with levels or descriptions that cannot be ordered, such as region of the country (North, South, East, and West)
* Ordinal data: variables that can be ordered, such as those from a Likert scale (strongly disagree, disagree, agree, and strongly agree)
* Interval/ratio: variables that are counted or measured, such as age or income
  * Within interval/ratio data are *discrete* variables, whose values are whole numbers, such as number of children, and *continuous* variables, whose values can lie anywhere on an interval, such as weight.
  
We use different measures based on whether our variables are interval/ratio, ordinal, or nominal.

## Descriptive analysis using the {srvyr} package

### Setup

Recall from [Chapter 05](#c05) the general process for estimation with the {srvyr} package:

1. Create a `tbl_svy` object using `srvyr::as_survey_design()` or `srvyr::as_survey_rep()`.
2. Subset the data for subpopulations using `dplyr::filter()`, if needed.
3. Specify domains of analysis using `dplyr::group_by()`, if needed.
4. Within `srvyr::summarize()`, specify variables to calculate ,means, totals, proportions, quantiles, and more.

The Residential Energy Consumption Survey (RECS) provides data on energy consumption and expenditures. It is funded by Energy Information Administration and collects information through energy suppliers through in-person, phone, and web interviews. It has been fielded 14 times between 1950 and 2020. Topics include appliances, electronics, heating, air conditioning (A/C), temperatures, water heating, lighting, energy bills, respondent demographics, and energy assistance.

The survey targets primary occupied housing units in the US. RECS uses Balanced Repeated Replication (BRR) to estimate the variances. The full sample information is available on the [EIA website](https://www.eia.gov/consumption/residential/index.php). 

To begin analyzing RECS, we create a `tbl_svy` object using `srvyr::as_survey_design()`:

```{r recs_des}
#| error: FALSE
#| warning: FALSE
#| message: FALSE
library(survey) # for survey analysis
library(srvyr) # for tidy survey analysis
library(readr)
library(here)

recs <-
  read_rds(here::here(
    "data", "recs.rds"
  ))

recs_des <- recs %>%
  as_survey_rep(
    weights = NWEIGHT,
    repweights = starts_with("BRRWT"),
    type = "Fay",
    rho = 0.5,
    mse = TRUE
  )
```

### Count observations using survey methods with `survey_count()`

With `srvyr::survey_count()`, you can produce weighted counts and variance of your choice. The syntax is very similar to the `dplyr::count()` syntax. However, it can only be called on `tbl_srvy()` objects. Let's explore the syntax:

```r
survey_count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = "n",
  .drop = dplyr::group_by_drop_default(x),
  vartype = c("se", "ci", "var", "cv")
  )
```

The arguments are:

* `x`: a `tbl_svy` object created by `as_survey`
* `...`: variables to group by, passed to `group_by`
* `wt`: a variable to weight on in addition to the survey weights, defaults to `NULL`
* `sort`: how to sort the variables, defaults to `FALSE`
* `name`: the name of the count variable, defaults to `n`
* `.drop`: whether to drop empty groups
* `vartype`: type(s) of variation estimate to calculate, defaults to `se` (standard error)

The steps to use `survey_count()` are:

* Specify the sample design,
* Filter subsets using `dplyr::filter()`, if needed
* Run `survey_count()`, specifying the required arguments within the function

Let's see the weighted count of responses in RECS:

```{r}
recs_des %>% #  Specify the sample design
  survey_count() # Run `survey_count()`
```

There are 118,208,250 weighted total responses in the survey.

`srvyr::count()` can take one or many variables. To calculate a cross-tab of population in each age group and gender, we run the below:

```{r}
recs_des %>%
  # Specify the required arguments within the function
  survey_count(Region, Division, name = "N") 
```

### Calculate totals using survey methods using `survey_total()`

With `srvyr::survey_total()`, we can calculate totals from complex survey data. Let's explore the syntax:

```r
survey_total(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  deff = FALSE,
  df = NULL,
  ...
)
```

* `x`: a variable, expression, or empty
* `na.rm`: an indicator of whether missing values should be dropped, defaults to `FALSE`
* `vartype`: type(s) of variation estimate to calculate, defaults to `se` (standard error)
* `level`: a number or a vector indicating the confidence level, defaults to 0.95
* `deff`: a logical value stating whether the design effect should be returned, defaults to FALSE
* `df`: for `vartype = 'ci'`), a numeric value indicating degrees of freedom for the t-distribution
  * For the {srvyr} package, this defaults to `NULL` whereas the {survey} package defaults to `Inf`

The steps to use `survey_total()` are:

* Specify the sample design,
* Specify the cross tab in `group_by()`,
* Within `summarize`, run `survey_total()`, specifying the required arguments within the function

To calculate a population count estimate with `survey_total()`, we can run the below:

```{r}
recs_des %>%
  summarize(survey_total(), .groups = "drop")
```

The `.groups =` argument controls the grouping structure of the output. When the output no longer have grouping variables because they are dropped, it becomes ungrouped. <!-- TODO: Check this after dplyr 1.1.0 is released -->

Notice that `recs_des %>% summarize(survey_total(), .groups = "drop")` is equivalent to the `survey_count()` call:

```{r}
recs_des %>%
  survey_count() 
```

The `survey_total()` function is called within `summarize`, where as `survey_count()`, like `dplyr::count()`, is not.

### Calculate mean/proportion using survey methods with `survey_mean()` and `survey_prop()`

The `srvyr::survey_mean()` and `survey_prop()` functions calculate the means and proportions from complex survey data. Like `survey_total()`, they are called within `summarize()`. Let's explore the syntax:

```r
survey_mean(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = FALSE,
  prop_method = c("logit", "likelihood", "asin", "beta", "mean"),
  deff = FALSE,
  df = NULL,
  ...
)

survey_prop(
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = FALSE,
  prop_method = c("logit", "likelihood", "asin", "beta", "mean"),
  deff = FALSE,
  df = NULL,
  ...
)
```

The steps involved are:

* Specify the sample design,
* Specify the cross tab in `group_by()`,
* Run `survey_mean()` or `survey_prop()` within `summarize()`

Looking at responses by urbanicity, we can calculate the weighted proportion for each group in the data:

```{r survey_p_ex1}
recs_des %>%
  group_by(Urbanicity) %>%
  summarize(p1 = survey_prop(),
            .groups = "drop")
```

69.6% of the responses are from people in urban areas, 10.5% from urban clusters, and 19.8% from rural areas.

The `survey_prop()` function is equivalent to leaving out the `x` argument in `survey_mean()`.

```{r}
recs_des %>%
  group_by(Urbanicity) %>%
  summarize(p1 = survey_prop(),
            .groups = "drop")
```

### Calculate proportions with confidence intervals

We calculate confidence intervals by setting the `vartype` to `ci` within `summarize` when using `survey_mean()` or `survey_mean()`. The confidence intervals provide us with an upper and lower column for each method.

```{r survey_p_ci}
recs_des %>%
  group_by(Urbanicity) %>%
  summarize(pd = survey_prop(
    vartype = "ci"
    ) %>% round(4))
```

We can change the proportion method by adding `prop_method`. The available options are `"logit"`, `"likelihood"`, `"asin"`, `"beta"`, and `"mean"`.

Using `proportion = TRUE` makes confidence intervals more accurate near 0 and 1.

```{r}
recs_des %>%
  group_by(Urbanicity) %>%
  summarize(pl = survey_prop(
    proportion = TRUE,
    prop_method = "logit",
    vartype = "ci"
  ) %>% round(4))
```

### Other functions that use survey methods

The {srvyr} package includes other functions for summarizing datasets, as mentioned in the section on types of descriptive analysis.

* Center: `survey_mean()`, `survey_median()`
* Count: `survey_count()`, `survey_total()`
* Distribution: `survey_ratio()`, `survey_prop()`
* Range: `survey_quantile()`
* Variance: `survey_var()`, `survey_sd()`

While we will not cover each one in depth; however, the same principles above apply.

### Calculate conditional proportions with more than one group

Specifying more than one group calculates conditional proportions. Say we wanted to know the proportion of respondents who live in rural regions in the Northeast. After the `tbl_svy` object, we specify the two variables we want to calculate proportions for:

```{r survey_p_cond, tidy=FALSE}
recs_des %>%
  group_by(Region, Urbanicity) %>%
  summarize(
    p = survey_mean(),
    N = survey_total(),
    n = unweighted(n()),
    .groups = "drop"
  )
```

From the table, we see that the weighted proportion is 15.5%. Note that column `p` is the proportion of **respondents in rural areas by region**. That is, it is the weighted number of people in rural areas in the Northeast (3,257,375), divided by the weighted number of respondents in the Northeast (15,595,476 + 2,153,686 + 3,257,375).

### Calculate joint proportions with more than one group

When we want to calculate multiple variables as if they were a single variable, we use {srvyr}'s `interact`. We use `interact` within `group_by()` to calculate the  joint proportions of two or more variables.

```{r survey_p_joint}
recs_des %>%
  group_by(interact(Region, Urbanicity)) %>%
  summarize(p = survey_mean(),
            N = survey_total(),
            .groups = "drop")
```

Since `interact` groups by multiple variables as if they were a single variable, the proportions in column `p` sum to 100% across more than a single grouping variable.

```{r}
recs_des %>%
  filter(!is.na(VotedPres2020),!is.na(VotedPres2016)) %>%
  group_by(interact(VotedPres2016, VotedPres2020)) %>% #<<
  summarize(p = survey_mean(),
            N = survey_total(),
            .groups = "drop") %>% 
  summarize(p_sum = sum(p))
```

### Calculate proportions with design effects

Note above that functions `survey_total()`, `survey_mean()`, and `survey_prop()` have the argument `deff`. `deff` stands for Design Effect, the ratio of two variances. Use `deff = TRUE` argument to specify whether the design effect should be returned.

```{r survey_p_deff}
recs_des %>%
  filter(!is.na(VotedPres2016),!is.na(VotedPres2020)) %>%
  group_by(interact(VotedPres2016, VotedPres2020)) %>%
  summarize(p = survey_mean(deff = TRUE), #<<
            N = survey_total())
```

## Summary


