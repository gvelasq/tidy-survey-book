# Descriptive analyses in srvyr {#c06}

## Introduction
<!-- Definition of descriptive analytics in the context of complex survey analysis -->
Descriptive analysis describes and summarizes the basic quantitative information of survey data. Common descriptive analyses include the frequency of observations, distributions of responses, or the mean of a numeric variable. In addition to getting a sense of our data, descriptive analysis helps us identify potential errors and assess outliers.  Running descriptive analysis allows us to investigate our data and gain insight into the information it contains, and it is crucial for conducting further survey analysis.
<!-- Importance of considering the design and sampling of the survey when analyzing data-->

In complex survey analysis, we must consider the available design and sampling elements when conducting descriptive analysis. This requires reading the survey documentation (as described in Chapter 03) to apply the appropriate sampling weights, PSUs, strata, and replicate weights. Neglecting to incorporate these elements can lead to inaccurate descriptive analyses.

The functions in the {srvyr} package allows us to run descriptive analyses while applying design and sampling elements. We can run multiple calculations at the same time thanks to the 'pipe-able' functions. The package also provides consistent return types, so we can use the results with other packages like {ggplot2}.
<!-- Overview of the topics covered in the chapter -->
In this chapter, we describe the types of descriptive analytics and the steps involved in running descriptive analysis with {srvyr}.
<!-- ## Techniques for descriptive analyses -->

```{r}
#| include: false
library(srvyr)
library(survey)
data(api)

dstrata <- apistrat %>%
  as_survey_design(strata = stype, weights = pw)
```

## Types of descriptive analyses

Descriptive analysis can be categorized into univariate analysis and multivariate analysis, depending on the number of variables we are describing. Below, we describe the descriptive analysis for single or multiple variables, as well as a minimal example of the {srvyr} functions associated with the measures.

### Univariate analysis

Univariate analysis examines a single variable at a time. A single variable has three categories of characteristics: distribution, central tendency, and dispersion. Each characteristic simplifies our dataset. Therefore, it is important to look at multiple characteristics rather than rely on a single one to describe the data.

#### Measures of distribution

Measures of distribution describe how often an event or response is likely to occur. These measures include proportions and quantiles.

* Examples: the proportion of a students in California who did or did not receive an award based on their Academic Performance score; the proportion of U.S. citizens who voted in the last election; the distribution of household income in India divided into quantiles

The {srvyr} package includes several functions for determining measures of distribution. 

* The `survey_total()` function calculates totals
* The `survey_count()` and `survey_tally()` functions calculate weighted observations by group
* The `survey_prop()` function calculates proportions
* The `survey_quantile()` function calculates quantiles
* The `survey_ratio()` function calculates ratios

For instance, if we want to calculate the proportion of students who received awards for their Academic Performance scores, we run the below:

```{r}
# Calculate the survey proportion of API Awards (Yes/No)

dstrata %>%
  group_by(awards) %>%
  summarise(pct = survey_prop())
```

#### Measures of central tendency

Measures of central tendency find the central (or average) responses. These include the mean, median, and mode.

* Examples: Average 2000 Academic Performance Index in California, the median house price in Canada

The `survey_mean()` and `survey_median()` functions from {srvyr} calculate mean and median using survey data, respectively.

```{r}
# Calculate survey mean of variable api00

dstrata %>%
  group_by(awards) %>%
  summarise(api00_mean = survey_mean(api00),
            api00_median = survey_median(api00))
```

#### Measures of dispersion

Measures of dispersion describe how data is spread around the central tendency. For these measures, we can calculate the range and standard deviation.

* Examples: The standard deviation of the 2000 Academic Performance Index in California, the range between the minimum and maximum electricity expenditure in Ohio

The `survey_var()` and `survey_sd()` functions from the {srvyr} package calculate population variance and standard deviation using survey methods, respectively.

```{r}
# Calculate the variance and standard deviation 
dstrata %>%
  summarise(api99_var = survey_var(api00),
            api99_sd = survey_sd(api00))
```

#### A brief refresher on the `dplyr::summarize()` function
<!-- TODO: Put this in a callout box -->
The `dplyr::summarize()` function collapses many values down to a single summary:

```{r}
mtcars %>% 
  summarize(mean_hp = mean(hp))
```

These verbs can be used in conjunction with `group_by()`, applying the functions on a group-by-group basis to create grouped summaries.

```{r}
mtcars %>% 
  group_by(cyl) %>% 
  summarize(mean_hp = mean(hp))
```
<!--TODO: end callout note-->

### Multivariate analysis

Multivariate analysis studies the relationship between multiple variables.

* Examples:

## Deciding on descriptive analyses

Choosing which measures are appropriate depend on the type of variable being examined. Variables are classified as categorical/nominal, ordinal, and interval/ratio.

* Categorical/nominal data: variables with levels or descriptions that cannot be ordered, such as region of the country (North, South, East, and West)
* Ordinal data: variables that can be ordered, such as those from a Likert scale (strongly disagree, disagree, agree, and strongly agree)
* Interval/ratio: variables that are counted or measured, such as age or income
  * Within interval/ratio data are *discrete* variables, whose values are whole numbers, such as number of children, and *continuous* variables, whose values can lie anywhere on an interval, such as weight.
  
Determining the appropriate descriptive analysis depends on the type of variable being examined. We should use different measures depending on whether our variables are interval/ratio, ordinal, or nominal.

## Descriptive analysis using the {srvyr} package

### Setup

Recall from [Chapter 05](#c05) the general process for estimation with the {srvyr} package:

1. Create a `tbl_svy` object using `srvyr::as_survey_design()` or `srvyr::as_survey_rep()`.
2. Subset the data for subpopulations using `dplyr::filter()`, if needed.
3. Specify domains of analysis using `dplyr::group_by()`, if needed.
4. Within `srvyr::summarize()`, specify variables to calculate ,means, totals, proportions, quantiles, and more.

With the ANES data, we create a `tbl_svy` object using `srvyr::as_survey_design()`,  adjusting the weight to add up to the citizen population:

```{r anes_des}
#| error: FALSE
#| warning: FALSE
#| message: FALSE
library(survey) # for survey analysis
library(srvyr) # for tidy survey analysis
library(readr)
library(here)

anes <-
  read_rds(here::here(
    "data", "anes_2020.rds"
  )) %>%
  mutate(Weight = Weight / sum(Weight) * 231592693)

anes_des <- anes %>%
  as_survey_design(
    weights = Weight,
    strata = Stratum,
    ids = VarUnit,
    nest = TRUE
  )
```

### Count observations using survey methods with `survey_count()`

With `srvyr::survey_count()`, you can produce weighted counts and variance of your choice. The syntax is very similar to the `dplyr::count()` syntax. However, it can only be called on `tbl_srvy()` objects. Let's explore the syntax:

```r
survey_count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = "n",
  .drop = dplyr::group_by_drop_default(x),
  vartype = c("se", "ci", "var", "cv")
  )
```

The arguments are:

* `x`: a `tbl_svy` object created by `as_survey`
* `...`: variables to group by, passed to `group_by`
* `wt`: a variable to weight on in addition to the survey weights, defaults to `NULL`
* `sort`: how to sort the variables, defaults to `FALSE`
* `name`: the name of the count variable, defaults to `n`
* `.drop`: whether to drop empty groups
* `vartype`: type(s) of variation estimate to calculate, defaults to `se` (standard error)

The steps to use `survey_count()` are:

* Specify the sample design,
* Filter subsets using `dplyr::filter()`, if needed
* Run `survey_count()`, specifying the required arguments within the function

Let's see the weighted count of responses in ANES:

```{r}
anes_des %>% #  Specify the sample design
  survey_count() # Run `survey_count()`
```

`srvyr::count()` can take one or many variables. To calculate a cross-tab of population in each age group and gender, we run the below:

```{r}
anes_des %>%
  # Specify the required arguments within the function
  survey_count(AgeGroup, Gender, name = "N") 
```

### Calculate totals using survey methods using `survey_total()`

With `srvyr::survey_total()`, we can calculate totals from complex survey data. Let's explore the syntax:

```r
survey_total(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  deff = FALSE,
  df = NULL,
  ...
)
```

* `x`: a variable, expression, or empty
* `na.rm`: an indicator of whether missing values should be dropped, defaults to `FALSE`
* `vartype`: type(s) of variation estimate to calculate, defaults to `se` (standard error)
* `level`: a number or a vector indicating the confidence level, defaults to 0.95
* `deff`: a logical value stating whether the design effect should be returned, defaults to FALSE
* `df`: for `vartype = 'ci'`), a numeric value indicating degrees of freedom for the t-distribution
  * For the {srvyr} package, this defaults to `NULL` whereas the {survey} package defaults to `Inf`

The steps to use `survey_total()` are:

* Specify the sample design,
* Specify the cross tab in `group_by()`,
* Within `summarize`, run `survey_total()`, specifying the required arguments within the function

To calculate a population count estimate with `survey_total()`, we can run the below:

```{r}
anes_des %>%
  summarize(survey_total(), .groups = "drop")
```

The `.groups =` argument controls the grouping structure of the output. When the output no longer have grouping variables because they are dropped, it becomes ungrouped. <!-- TODO: Check this after dplyr 1.1.0 is released -->

Notice that `anes_des %>% summarize(survey_total(), .groups = "drop")` is equivalent to the `survey_count()` call:

```{r}
anes_des %>%
  survey_count() 
```

The `survey_total()` function is called within `summarize`, where as `survey_count()`, like `dplyr::count()`, is not.

### Calculate mean/proportion using survey methods with `survey_mean()` and `survey_prop()`

The `srvyr::survey_mean()` and `survey_prop()` functions calculate the means and proportions from complex survey data. Like `survey_total()`, they are called within `summarize()`. Let's explore the syntax:

```r
survey_mean(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = FALSE,
  prop_method = c("logit", "likelihood", "asin", "beta", "mean"),
  deff = FALSE,
  df = NULL,
  ...
)

survey_prop(
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = FALSE,
  prop_method = c("logit", "likelihood", "asin", "beta", "mean"),
  deff = FALSE,
  df = NULL,
  ...
)
```

The steps involved are:

* Specify the sample design,
* Specify the cross tab in `group_by()`,
* Run `survey_mean()` or `survey_prop()` within `summarize()`

Looking at population by age group, we can calculate the weighted proportion for each group in the data:

```{r survey_p_ex1}
anes_des %>%
  group_by(AgeGroup) %>%
  summarize(p1 = survey_mean(),
            .groups = "drop")
```

The `survey_prop()` function is equivalent to leaving out the `x` argument in `survey_mean()`.

```{r}
anes_des %>%
  group_by(AgeGroup) %>%
  summarize(p1 = survey_prop(),
            .groups = "drop")
```

### Calculate proportions with confidence intervals

We can also calculate confidence intervals within `summarize` using `survey_mean()` or `survey_mean()` by setting the `vartype` to `ci`. The confidence intervals provide us with an upper and lower column for each method.

```{r survey_p_ci}
anes_des %>%
  group_by(Income7, VotedPres2016, VotedPres2020) %>%
  summarize(pd = survey_prop(vartype = "ci") %>% round(4)) %>%
  select(Income7, VotedPres2016, VotedPres2020, contains("_"))
```

We can change the proportion method by adding `prop_method`. The available options are: `"logit"`, `"likelihood"`, `"asin"`, `"beta"`, and `"mean"`.

Using `proportion = TRUE` make confidence intervals more accurate near 0 and 1.

```{r}
anes_des %>%
  group_by(Income7, VotedPres2016, VotedPres2020) %>%
  summarize(pl = survey_prop(
    proportion = TRUE,
    prop_method = "logit",
    vartype = "ci"
  ) %>% round(4)) %>% 
  select(Income7, VotedPres2016, VotedPres2020, contains("_"))
```

### Other functions that use survey methods

The {srvyr} package includes other functions for summarizing datasets, as mentioned in the section on types of descriptive analysis. Here is the full list:

* Center: `survey_mean()`, `survey_median()`
* Count: `survey_count()`, `survey_total()`
* Distribution: `survey_ratio()`, `survey_prop()`
* Range: `survey_quantile()`
* Variance: `survey_var()`, `survey_sd()`

While we will not cover each one in depth; however, the same principles that we have seen apply.

### Calculate conditional proportions with more than one group

Specifying more than one group calculates conditional proportions. Say we wanted to know the proportion of people who voted in 2016 and 2020. After the `tbl_svy` object, we specify the two variables we want to calculate proportions for:

```{r survey_p_cond, tidy=FALSE}
anes_des %>%
  filter(!is.na(VotedPres2016), !is.na(VotedPres2020)) %>%
  group_by(VotedPres2016, VotedPres2020) %>%
  summarize(
    p = survey_mean(),
    N = survey_total(),
    n = unweighted(n()),
    .groups = "drop"
  )
```

Note that this is the proportion of **people voting in 2020 by whether people voted in 2016**. That is, it is the weighted number of people who voted in both 2016 and 2020 (144578247), divided by the weighted number of people who voted in 2016 (144578247 + 11917394). Running the above, we see that 92.4% of people who voted in 2016 voted in 2020.

### Calculate joint proportions with more than one group

When we want to calculate multiple variables as if they were a single variable, we use {srvyr}'s `interact`. We use `interact` within `group_by()` to calculate the  joint proportions of two or more variables.

```{r survey_p_joint}
anes_des %>%
  filter(!is.na(VotedPres2020), !is.na(VotedPres2016)) %>%
  group_by(interact(VotedPres2016, VotedPres2020)) %>% #<<
  summarize(p = survey_mean(),
            N = survey_total(),
            .groups = "drop")
```

Since `interact` groups by multiple variables as if they were a single variable, the proportions sum to 100% across more than a single grouping variable.

```{r}
anes_des %>%
  filter(!is.na(VotedPres2020),!is.na(VotedPres2016)) %>%
  group_by(interact(VotedPres2016, VotedPres2020)) %>% #<<
  summarize(p = survey_mean(),
            N = survey_total(),
            .groups = "drop") %>% 
  summarize(p_sum = sum(p))
```

### Calculate proportions with design effects

Note above that functions `survey_total()`, `survey_mean()`, and `survey_prop()` have the argument `deff`. `deff` stands for Design Effect, the ratio of two variances. Use `deff = TRUE` argument to specify whether the design effect should be returned.

```{r survey_p_deff}
anes_des %>%
  filter(!is.na(VotedPres2016),!is.na(VotedPres2020)) %>%
  group_by(interact(VotedPres2016, VotedPres2020)) %>%
  summarize(p = survey_mean(deff = TRUE), #<<
            N = survey_total())
```